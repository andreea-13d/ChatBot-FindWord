CURS 1
PAGINA 2 
A gandi “orientat obiect” 
PAGINA 3
Evolutia programarii Cod masina Limbaj asamblare Limbaje independente de masina Proceduri si functii Obiecte Servicii 
PAGINA 4
Istoric ~1960 SIMULA 1 (1962) si Simula 67 (1967), Norwegian Computing Center in Oslo, Norway Smaltalk (1970) – XEROX "C with Classes", predecesorul C++, 1979, Bjarne Stroustrup 1995, Java dezvoltat de James Gosling la Sun Microsystems. 1980 – Revista Byte Prima conferinta dedicata OOP, Portland, Oregon, USA
PAGINA 5
Generalitati  POO a evoluat din programarea structurata (PS)  POO este: O idee revolutionara O evolutie normala  Aplicabilitate POO: sisteme distribuite PS: fluxuri de date, descompunere de procese 
PAGINA 6
Limbaj si gandire (1) M. Sapir (1956): “Oamenii se gasesc la cheremul unui limbaj particular care reprezinta mediul de comunicare in cadrul unei societati”  Limbajul influenteaza gandirea d.e. vocabularul extensiv (eschimosii si zapada) Concluzie: un limbaj OO poate simplifica dezvoltarea unei solutii OO 
PAGINA 7 
Limbaj si gandire (2) Exemplu: analiza secventei DNA: fie un vector cu N variabile in cadrul careia trebuie determinata o secventa repetitiva de lungime M Rezolvare intr’un limbaj standard: M x N x N operatii Rezolvare intr’un limbaj OO M x N x log(N) operatii Observatie: Limbajul OO NU este mai rapid decat limbajul structurat
PAGINA 8
Ipoteza lui Church & postulatul lui Whorf Ipoteza lui Church / Church-Turing (1936): orice rationament pentru care exista o “procedura efectiva” (i.e. are la baza un algoritm) poate fi realizat de o masina Turing. Reguli: • Numarul de instructiuni trebuie să fie finit. • Iesirea ar trebui să fie obtinuta dupa parcurgerea unui numar finit de pasi. • Instructiunile pot fi implementate în lumea reala. • Instructiunile nu ar trebui sa necesite o intelegere complexa. https://www.youtube.com/watch?v=0D7yInuKvKs
PAGINA 9
Ipoteza lui Church & postulatul lui Whorf Postulatul lui Whorf / Sapir-Whorf (1956): este posibil ca un individ, ce comunica intr’un limbaj, sa nu poata comunica ganduri / idei intr’un alt limbaj Astfel, se postuleaza faptul ca natura unei anumite limbi influenteaza gandirea obisnuita a vorbitorilor ei. Diferitele modele de limbaj genereaza diferite modele de gandire. Aceasta idee contesta posibilitatea reprezentarii perfecte a lumii cu limbajul, deoarece recunoaste ca mecanismele oricarei limbi conditioneaza gandurile comunitatii de vorbitori ai acesteia. https://study.com/academy/lesson/sapir-whorf-hypothesis-examples-anddefinition.html
PAGINA 10
Consecinte Pentru Ipoteza lui Church Orice limbaj in cadrul caruia poate fi simulata o masina Turing, este suficient de performant pentru a permite implementarea oricarui algoritm Toate limbajele de programare sunt identice Pentru Postulatul lui Whorf: Pot exista idei ce pot sa fie exprimate mai bine intr’un limbaj decat intr’altul Consecinta George Steiner (1975 - After Babel): orice act de comunicare umana poate fi vazut ca implica o traducere
PAGINA 11
O noua paradigma Programul OO creaza obiecte ce incapsuleaza date si procedure ce vor actiona asupra acelor date Un POO este structurat ca o comunitate de agenti / obiecte ce interactioneaza intre ele Fiecare obiect produce un serviciu sau realizeaza actiuni Exemplul florarului 
PAGINA 12
Caracteristicile POO O noua metoda de proiectare a aplicatiilor pornind de la o reprezentare naturala Programele sunt gandite a avea componente ce functioneaza independent, fiecare cu propriile proprietati si functionalitati Un sistem este proiectat ca o interconexiune de asemenea componente.
PAGINA 13
Caracteristicile programarii structurate Programele sunt gandite strict secvential Se utilizeaza branching conditions in cazul implementarii deciziilor Se utilizeaza functii / proceduri pentru implementarea secventelor repetabile. Sinteza: programele definesc date, dupa care apeleaza subprograme pentru a prelucra acele date
PAGINA 14
Limitarile programarii structurate In viata reala evenimentele nu sunt intotdeauna secventiale Nu este simplu de gasit solutii secventiale pentru problemele reale Codul aplicatiei nu poate fi re-utilizat si depanat independent Codul nu se poate “adapta” la situatiile in schimbare  Abordari OO sunt benefice in cadrul aplicatiilor de dimensiuni mari (>1000 linii de cod)
PAGINA 15
Actiunile sunt initiate in POO prin transmitere de mesaje de catre un agent (obiect) responsabil pentru o actiune Programele sunt gandite ca interactiuni / asocieri de obiecte In cadrul POO nu trebuie “anticipat” orice – ci trebuie doar utilizate serviciile obiectelor POO – un nou model de gandire
PAGINA 16
Programarea structurata
PAGINA 17
POO vs. Programarea structurata 
PAGINA 18
Evolutia limbajelor de programare (1) Generatia I (1954 - 1958) – formule matematice Fortran I, Algol 58, IPL Generatia II (1959 -1961) – algoritmi Fortran II, Algol, Cobol Generatia III (1962 - 1970) – abstractizare date PL/I, Pascal, Algol 68, C, Fortran77 Limbaje OO Smalltalk, C++, Eiffel Limbaje actuale: Java, Python, C#
PAGINA 19
Evolutia limbajelor de programare (2) 
PAGINA 20
Evolutia limbajelor de programare (3)
PAGINA 21
Evolutia limbajelor de programare (4) Generatia I Generatia II - Mecanisme de “transfer parametrii” - Dezvoltare stracturi de control – Subprograme
PAGINA 22
Evolutia limbajelor de programare (5) Generatia III Generatia IV
PAGINA 23
Evolutia limbajelor de programare (6)
PAGINA 24
Programarea functionala vs. Programarea procedurala vs. Programarea OO (1)
PAGINA 25
Programarea functionala vs. Programarea procedurala vs. Programarea OO (2)
PAGINA 26
Avantajele POO Analiza si proiectare mai facila Reutilizare cod O mai buna mentenanta a programelor Reducerea codului recurrent Mascarea informatiilor Robustete sporita O mai buna securitate a aplicatiilor
PAGINA 27
Concluzii … istorice “I think there is a world market for maybe five computers.” Thomas Watson, chairman of IBM, 1943 “Computers in the future may weigh no more than 1.5 tons.” Popular Mechanics, 1949 “There is no reason anyone would want a computer in their home.” Ken Olson, president, chairman and founder of Digital Equipment Corp., 1977
CURS 2
PAGINA 2
Conceptele de baza ale POO
PAGINA 3
Introducere Descompunerea sistemelor de mari dimensiuni: 1. algoritmic: pune in evidenta ordinea evenimentelor 2. Prin intermediul obiectelor: pune in evidenta elementele ce actioneaza / sunt supuse unor actiuni Diferente fata de abordarea clasica:  POO se bazeaza pe obiecte si nu pe algoritmi  Fiecare obiect este o instanta a unei clase  Clasele pot fi legate intre ele prin relatii de mostenir e Obs: daca una din aceste caracteristici lipseste, nu este vorba de programare OO
PAGINA 4
Stiluri de programare 1. Orientatate catre proceduri  algoritmi 2. Orientatate catre obiecte  clase si obiecte 3. Orientatate catre logica  scop (calcul predicativ) 4. Orientatate catre reguli  reguli de tip “if – then” 5. Orientatate catre constrangeri  relatii de invarianta
PAGINA 5
Principii de baza ale abordarii obiectuale
PAGINA 6
Ce este abstractizarea (1) ?  Exemplul atlasului:  scara de reprezentare a marimilor  Definitie: procedura de mascare a detaliilor unui obiect in scopul accentuarii / punerii in evidenta a altora specte / detalii / structuri  Nivele de abstractizare: 1. Cel mai de sus: comunitatea obiectelor ce trebuie sa interactioneze unele cu altele in vederea indeplinirii unui scop comun
PAGINA 7
Ce este abstractizarea (2) ? 2. Valabil in anumite limbaje OO: grup de obiecte ce lucreaza impreuna si care sunt grupate in unit-uri, d.e. package (Java), name spaces (C++) si units (Delphi) 3. Nivelul de interactiune intre 2 obiecte (interactiune client / server, C/S). In acest caz exista 2 sub-nivele de abstractizare: Abstractizare client  server Abstractizare server  client 
PAGINA 8 
Ce este abstractizarea (3) ? Tipuri de abstractizari: entitate / actiune / ms virtuala / incident Abstractizarea este legata de notiunea de “invarianta”; ruperea unei invariante conduce la lipsa vizibilitatii unor obiecte cu altele Orice abstractizare are proprietati Statice, de ex nume fisier Dinamice, de ex valoarea unei prop statice  un nume de fisier poate fi schimbat Consecinta: abstractizarea si incapsularea sunt concepte complementare, i.e. pentru ca abstractizarea sa functioneze, trebuie sa existe incapsulare
PAGINA 9
Ce este incapsularea ? Ascunde implementarea fata de clienti  Clientii depind de interfata
PAGINA 10
Incapsulare vs abstractizare 
PAGINA 11
Incapsulare vs abstractizare Utilizare • Abstractizare: rezolvă dificultatile ce apar în etapa de proiectare. • Încapsularea: rezolvă dificultatile ce apar în etapa de implementare. Focus • Abstractizare: focalizarea pe ceea ce face obiectul în loc de modul în care o face. • Încapsularea: permite ascunderea codului / datelor într’o singură unitate pentru a le securiza de lumea exterioară.
PAGINA 12
Incapsulare vs abstractizare Implementare Abstractizare: se utilizeaza folosind Interfața și Clasa abstractă. Încapsulare: se utilizeaza folosind Modificatori de acces (Public, Protejat și Privat.) Utilizare Abstractizare: ceea ce ar trebui făcut. Încapsulare: modul în care ar trebui făcut. Aplicabilitate Abstractizare: În timpul proiectarii. Încapsulare: În timpul implementarii.
PAGINA 13
Ce este polimorfismul ? descrie situațiile în care “ceva” se întâmplă în mai multe forme diferite. În informatică, polimorfismul descrie conceptul accesarii de obiecte de diferite tipuri prin aceeași interfață.
PAGINA 14
Ce este mostenirea ? Ierarhia reprezinta o ordonare a abstractizarii.
PAGINA 15
Concepte de baza ale POO Obiect Clasa Atribut Operatie Componenta / modularitate Mostenire Incapsularea Polimorfism
PAGINA 16
Obiecte (1) Un obiect reprezinta o entitate (fizica, conceptuala sau soft) 1.Entitate fizica 2.Entitate conceptuala 3.Entitate software Peste Piramide Componenta (subsistem)
PAGINA 17
Obiecte (2) Definitie formala: un obiect este un concept (real sau abstract) cu frontiere bine definite si posibilitate de actiune. Se caracterizeaza prin: Evolutie – influentata de istoricitatea obiectului (d.e. automatul pentru bauturi); reprez modul in care obiectele actioneaza / reactioneaza in termini de modificare de stare si schimb de mesaje Stare: orice obiect are o stare, i.e. ocupa un spatiu fizic de memorie Identitate unica: “propietatea unui obiect ce il face distinct fata de un alt obiect” (Copeland)
PAGINA 18
Starea unui obiect Starea unui obiect reprezinta una din conditiile posibile de existenta ale acestuia In mod normal, starea unui obiect se schimba in timp Este reprezentata de: Valorile atributelor + Instantele relatiilor (relationship instances ) Sofer Nume: Ion Popescu ID: 123456789 Data angajarii: 01.01.01
PAGINA 19
Evolutia determina modul in care obiectele (re)actioneaza la solicitarile altor obiecte. Evolutia unui obiect este reprezentata de totalitatea raspunsurilor la setul de mesaje primite (i.e. totalitatea operatiilor pe care un obiect le poate realiza) Observatie: orice obiect are o identitate unica (chiar daca starea sa este identica cu cea a unui alt obiect) Evolutia unui obiect (1) Sistem de inregistrareCurs 100 – Geometrie Conformitate Asignare curs
PAGINA 20
Operatii De modificare: altereaza starea unui obiect De selectie: operatia acceseaza starea unui obiect dar NU o altereaza De iteratie: operatia prin care se permite ca toate partile unui obiect sa poata fi accesate intr’o ordine predefinita Constructor: crearea unui obiect si/sau initializarea starii acestuia Destructor: elibereaza starea unui obiect si/sau il distruge Evolutia unui obiect (2)
PAGINA 21
Clase Ansamblul obiectelor cu aceeasi semantica, proprietati (atribute) similare si comportament comun Un obiect reprezinta instanta a unei clase Gruparea obiectelor in clase reprezinta rezultatul unei operatii de abstractizare: Evidentierea caracteristicilor comune Eliminarea elementelor nespecifice
PAGINA 22
Masina Atribute: Model Serie_motor An_fabricatie Operatii: Deplasare Reparare Oprire Clasa – exemplu
PAGINA 23
Clase & obiecte – exemplu © Faculty of Computer Science & Information System, UTMClasa “Arbore” Obiecte (instantieri ale clasei): arbori, cu atribut inaltime
PAGINA 24
Tipuri de clase Clasa abstracta. O clasa incompleta care defineste elementele comune a mai multor clase Fara instantiere. Clasa concreta O clasa completa Descrie complet un anumit concept Poate avea instantieri
PAGINA 25
Relatii intre obiecte si clase O clasa reprezinta o definitie abstracta a unui obiect Defineste structura si evolutia pentru fiece obiect ce apartine clasei respective Poate fi un template pentru crearea de obiecte Obiectele pot fi grupate in clase
PAGINA 26
Atribute & operatii Atributele reprezintă diferitele caracteristici ale clasei. Ele pot fi, de asemenea, denumite caracteristici ale clasei si pot diferenția o clasă de alte clase. Operatiile (metodele) sunt responsabile cu definirea / modificarea comportamentului unei clase și al obiectelor aferente acesteia.
PAGINA 27
Modularitate Modularitatea reprezinta procesul de descompunere a unei probleme (program) într’un set de module, astfel încât să reducă complexitatea generală a problemei. Modularitatea (Booch): „Modularitatea reprezinta proprietatea unui sistem care a fost descompus într-un set de module coezive și slab cuplate.” Modularitatea este intrinsec legată de încapsulare. Modularitatea poate fi vizualizată ca o modalitate de a mapa abstracțiile încapsulate în module reale, fizice, cu o coeziune ridicată în cadrul modulelor, iar interacțiunea sau cuplarea lor între module trebuie sa fie scăzută.
PAGINA 28
Caracteristici modularitate Exista programe (d.e. Smalltalk) ce nu contin module (i.e. clasa reprez. singura unitate fizica de descompunere) Scopul modularizarii: reducerea costurilor prin accesarea independenta a fiecarui modul  In general clasa + obiect se regasesc in module
PAGINA 29
Componenta Partea unui sistem ne-triviala si inlocuibila ce indeplineste o functie bine precizata in contextul unei arhitecturi bine definite. O componenta poate fi: Cod sursa O structura executabila
PAGINA 30
Proprietatea de partajare a atributelor si operatiilor unei / unor clase de catre alta / alte clase in cadrul relatiilor ierarhice, diferentele ramanand neschimbate Prin mostenire se pot exprima relatii de: Generalizare Specializare Clasificare Aproximatie Evolutie Tipuri de mosteniri: Simple Multiple Mostenire 
PAGINA 31
Generalizare
PAGINA 32
Gruparea detaliilor de implementare intr’o zona ascunsa, inaccesibila din exterior Consecinta: reducerea gradului de interdependenta dintre elemente Incapsularea
PAGINA 33
Vizibilitatea claselor este structurata pe trei nivele: Public  toti! Privat  proprie unei clase Protejat  vizibilitate la nivelul subclasei Incapsularea
PAGINA 34
1. Dezvoltarea de componente software trebuie sa furnizeze utilizatorilor toata informatia necesara spre o buna utilizare a componentelor, dar NICI o alta informatie in plus. 2. Dezvoltatorul de componente software trebuie sa primeasca toata informatia necesara in vederea finalizarii cu succes a responsabilitatilor sale referitoare la componente, dar NICI o alta informatie in plus. Principiile lui David Parnas
PAGINA 35
Incapsulare – consecinte Obiectele incapsuleaza atat datele cat si procedurile aferente manipularii datelor
PAGINA 36
Capacitatea unui operator de a se aplica obiectelor din clase diferite Polimorfism (1) Deplasare Deplasare Deplasare
PAGINA 37
sau Abilitatea unui operator de a masca implementari diferite in spatele unei interfete unice Polimorfism (2)
PAGINA 38
O singura paradigma Un singur limbaj utilizat de utilizatori, analisti, proiectanti, etc. Faciliteaza re-utilizarea codului si structurile arhitecturale Modeleaza mai corect lumea reala: Descriere mai precisa a fluxurilor de date si a proceselor aferente Descompuneri naturale ale structurilor mari Usor de inteles si de intretinut Stabilitate O mica schimbare la nivelul cerintelor nu conduce la modificari profunde in sistemul aflat in faza de dezvoltare Puncte tari ale POO
PAGINA 39
Lungimea programelor dezvoltate folosind limbajul OOP este mult mai mare decât abordarea procedurală. Deoarece programul devine mai mare, este nevoie de mai mult timp pentru a fi executat, ceea ce duce la o execuție mai lentă a programului. Nu se poate aplica OOP peste tot, deoarece nu este un limbaj universal. Se aplică numai atunci când este necesar. Nu este potrivit pentru toate tipurile de probleme. Procesul de gândire implicat în programarea orientată pe obiecte poate să nu fie natural pentru unii oameni. Puncte slabe ale POO
CURS 3
PAGINA 2
Analiza, proiectarea si programarea orientata obiect
PAGINA 3
Sistem informatic Acea parte a sistemului informational a unei organizatii in care stocarea / prelucrarea datelor se realizeaza prin mijloace informatice El este format din aplicatia / produsul informatic si elementele folosite pentru exploatarea sa de catre utilizatori Ciclul de viata al SI: defineste perioada de timp dintre “nasterea” (punerea in functiune) si “moarte” (inlocuire)
PAGINA 4
Dezvoltarea aplicatiilor OO
PAGINA 5
Analiza si proiectarea OO Analiza: Intelegerea, gasirea si descrierea conceptelor in domeniul problemei Proiectarea: Structurarea solutiei soft pornind de la etapa de analiza pana la nivel de implementare
PAGINA 6
Analiza vs. proiectare Analiza  Evolutie  Structura sistem  Cerinte functionale  Model (in mic) Proiectare Operatii si atribute Performanta Usor de programat Ciclul de viata al obiectelor Cerinte non-functionale Model (in mare
PAGINA 7
Ciclul de viata al soft-ului Unde se regaseste abordarea OO ?

PAGINA 8
Obiecte vs. functii
PAGINA 9
Cerintele dezvoltarii SI Functionale Nefunctionale: Securitate / protectie Flexibilitate Robustete
PAGINA 10
Modele de dezvoltare (1) Linear Cascada Agile Spirala V-model
PAGINA 11
Modele de dezvoltare (2) Modelul linear 1. Proiectele reale urmează rareori fluxul secvenţial pe care îl propune modelul. 2. Este adesea dificil pentru client să precizeze toate cerințele în mod explicit. Modelul liniar are dificultăţi în adaptarea incertitudinii naturale care există la începutul multor proiecte. 3. Clientul trebuie să aibă răbdare. O versiune de lucru a programului (programelor) nu va fi disponibilă până târziu, pe parcursul implementarii proiectului. O gafă majoră, dacă nu este detectată până când programul de lucru este revizuit, poate fi dezastruoasă
PAGINA 12
Modele de dezvoltare (3) Modelul linear – dezavantaje: Controlul se modifica pe parcursul procesului Necesita ca toate constrangerile sa fie corect specificate inca de la inceputul procesului Versiunea functionala a unui program este livrata la sfasitul ciclului; erori in faze de inceput pot fi catastrofale.
PAGINA 13
Modele de dezvoltare (4) Modelul cascada ilustreaza procesul de dezvoltare software intr’un flux linear / secvential. Fiecare faza trebuie finalizata inainte ca urmatoarea faza sa poata incepe si nu exista suprapuneri intre faze. Toate cerintele posibile sunt inregistrate in documentele privind cerintele produsului. Fiecare faza corespunde unei activitati si trebuie sa se termine la o anumita data prin producerea anumitor documente sau programe.
PAGINA 14
Modele de dezvoltare (5) Cand se foloseste?  Cerințele sunt foarte bine documentate, clare si fixe;  Definiția produsului este stabilă;  Tehnologia este înțeleasă și nu este dinamică;  Nu există cerințe ambigue;  Aplicația nu este complicata  Când există un flux accentuat al personalului firmei;  Resurse suficiente.
PAGINA 15
Modele de dezvoltare (6) Modelul Agile se concentreaza pe adaptabilitatea procesului și satisfactia clientilor prin livrarea rapida a produselor software funcționale. Metodele Agile impart produsul in mici versiuni incrementale. Aceste versiuni sunt furnizate in iteratii.
PAGINA 16
Modele de dezvoltare (7) Agile vs model cascada
PAGINA 17
Modele de dezvoltare (8) Un „model spiralat” este un tip de model iterativ în care iterațiile individuale din modelul spiralat iau forma unor mini-cascade. Modelul în spirală oferă suport pentru gestionarea riscurilor. Un risc este orice situație adversă care ar putea afecta realizarea cu succes a unui proiect. Cea mai importantă caracteristică a modelului spiralat o reprezinta gestionarea acestor riscuri necunoscute după începerea proiectului.
PAGINA 18
Modele de dezvoltare (9) Cand se foloseste?  Atunci când există o constrângere bugetară și evaluarea riscurilor este importantă.  Pentru proiecte cu risc mediu spre mare.  Angajamentul pe termen lung al proiectului din cauza potențialelor modificări ale priorităților economice pe măsură ce cerințele se schimbă în timp.  Clientul nu este sigur de cerințele sale, ceea ce este de obicei cazul.  Cerințele sunt complexe și necesită evaluare pentru a obține claritate.  O nouă linie de produse ar trebui lansată în etape pentru a obține suficient feedback de la clienti.  Se așteaptă modificări semnificative ale produsului în timpul ciclului de dezvoltare
PAGINA 19
Modele de dezvoltare (10) V-Model reprezinta un ciclu de viata de dezvoltare software care subliniază conceptul de „verificare și validare”. In fiecare etapă de dezvoltare a modelului V, va exista o faza de testare corespunzătoare care va valida un astfel de proces. Fazele de testare vor fi planificate în paralel cu dezvoltarea etapei pe care se presupune ca vor fi testate De asemenea, este considerat a fi o formă extinsă a modelului de cascadă, deoarece un pas nu poate fi făcut fără finalizarea unui proces anterior.
PAGINA 20
Modele de dezvoltare (11
PAGINA 21
Cele 5 dimensiuni: scop, calitate, risc, timp, cost (1) Scopul trebuie cât mai bine definit și detaliat astfel încât echipa să nu devieze de la acesta. Timpul reprezintă resursa cea mai importantă, deoarece aceasta nu poate fi înlocuită. Orice deviere de la scop aduce timp irosit, iar acest lucru trebuie să fie acoperit în cadrul managementului de risc.
PAGINA 22
Cele 5 dimensiuni: scop, calitate, risc, timp, cost (2) Calitatea reprezinta ceea ce clientul sau stakeholderii au nevoie astfel încât proiectul să fie considerat un succes. La bază, calitatea proiectului este reprezentată de posibilitatea utilizatorului de a folosi acel produs. Managementul riscului reprezintă un proces continuu, proactiv şi sistematic de identificare, evaluare şi gestionare a riscurilor, realizat la nivelul fiecărei entităţi cu scopul de a furniza asigurări rezonabile în ceea ce privește atingerea obiectivelor. Costul este o componentă primordială deoarece scopul principal al proiectului este generarea de profit
PAGINA 23
Etapele dezvoltarii soft-ului (1) 1. Etapa de analiza porneste de la specificarea problemei de rezolvat si are ca rezultat modelarea OO: Modelul obiectual: pune in evidenta aspectele statice ale aplicatiei; sunt identificate conceptele cu care se lucreaza si li se asociaza clase si obiecte si relatiile aferente  diagrama de clase si diagrama de obiecte Modelul dinamic: evidentiaza aspectele dinamice ale claselor / obiectelor care au un comportament dinamic semnificativ; sunt stabilite starile prin care poate trece un obiect, evenimentele ce determina tranzitia dintr’o stare in alta, etc.
PAGINA 24
Etapele dezvoltarii soft-ului (2) Modelul functional: descrie functionarea, i.e. propietatile comportamentale ale obiectelor; sunt ilustrate relatiile dintre parametrii de I/O ale fiecarei fct, fara detalii privind implementarea algoritmului intr’un limbaj de programare 2. Etapa de proiectare trece de la aspectele conceptuale la elementele legate de implementarea directa a produsului soft Proiectarea sistemului: se iau decizii cu privire la arhitectura aplicatiei (resurse, platforma gazda) si modalitati de implementare (hard / soft)
PAGINA 25
Etapele dezvoltarii soft-ului (3) Proiectarea obiectelor: descrierea amanuntita a fiecarei clase. Pasi: Structurarea diagramelor de interactiuni pentru fiecare scenariu Structurarea detaliata a diagramelor de clase Etapa de implementare implica transpunerea proiectului intr’un limbaj de programare Etapa de testare: Testarea modulelor individuale Testarea sistemului (ca un tot unitar)
PAGINA 26
Etapele dezvoltarii soft-ului (4)
PAGINA 27
Elaborarea Modelului Obiectual – MO (1) Pentru construirea MO se identifica intai clasele si asociatiile; se adauga atributele si se utlizeaza mostenirea Etape: Se identifica clasele / obiectele; reguli: Evitarea claselor redundante Eliminarea claselor irelevante Declararea ca atribute a proprietatilor celor mai relevante ale obiectelor Se includ in clase operatiile ce sunt aplicate obiectelor Pregatirea unui dictionar de date, i.e. descrierea precisa a fiecarui obiect, asociatii, atribut si operatii
PAGINA 28
Elaborarea Modelului Obiectual – MO (2) Identificarea relatiilor de asociere (orice dependenta intre doua / mai multe clase sau o referire de la o clasa la alta); reguli: Se elimina asocierile irelevante Se elimina asocierile redundante Daca in procesul de analiza se elimina o clasa, asocierile corespunzatoare se elimina / se reformuleaza in functie de alte clase Majoritatea asocierilor intre 3 / mai multe clase pot fi descompuse in asocieri binare Indentificarea atributelor/operatiilor Organizarea claselor prin mostenire: De jos in sus: generalizare in superclasa De sus in jos: prin rafinarea claselor existente
PAGINA 29
Elaborarea Modelului Obiectual – MO (3) Iterarea modelului Gruparea claselor in module (o multime de clase ce reprezinta o submultime logica a intregului model) Definitii: Diagrama de clase: reflecta instatieri posibile ale datelor Diagrama de obiecte: descrie modul in care inter relationeazaun set de obiecte Relatia de agregare: daca asociatia exprima o relatie de tip “parte–intreg”
PAGINA 30
Elaborarea Modelului Dinamic – MD (1) Are la baza 2 concepte: Stare: Caracterizeaza setul de valori asociate obiectului Este o abstractizare a valorilor atributelor si legaturilor unui obiect Reprezinta raspunsul unui obiect la un eveniment (extern) Corespunde intervalului dintre 2 evenimente
PAGINA 31
Elaborarea Modelului Dinamic – MD (2) Eveniment: Caracterizeaza stimulii externi ce actioneaza asupra obiectelor. Reprezinta o transmitere unidirectionala de informatie (de la un obiect la altul). Special: erori Concurenta: doua sau mai multe evenimente necorelate cauzal Scenariu: secventa de evenimente ce apare intr’un caz particular de evolutie a sistemului.
PAGINA 32
Elaborarea Modelului Dinamic – MD (3) Operatii: Activitati: Sunt asociate starilor si necesita timp pentru a fi efectuate. Actiuni: Operatii instantanee asociate evenimentelor. MD al unei clase este mostenit de subclasele sale; acestea mostenesc atat starile cat si tranzitiile
PAGINA 33
Elaborarea Modelului Functional – MF Descrie modul in care se efectueaza calculele in interiorul unui sistem, fara a tine cont de secvente, decizii sau structuri Proces: transforma valorile datelor; rezultatele unui proces depind de comportamentul sistemului, specificat prin MD Flux de date: conecteaza iesirea unui proces cu intrarea altui proces
PAGINA 34
Ciclul de dezvoltare software
CURS 4
PAGINA 2
Introducere in UML (1)
PAGINA 3
 Ce este modelarea ? Aspecte generale privind modelarea Trasaturile modelarii: Simplificare (rezultatul abstractizarii) Subordonare unui scop Reprezentarea unei realitati Divizare Ierarhizare Comunicare Grupuri tinta: client/utilizatori si membrii echipa proiect
PAGINA 4 
Ce este modelarea vizuala (1) ? Modelarea vizuala permite modelarea prin notatii grafice standard Principii: Modul de creare tine de scopul utilizarii modelului Orice model poate fi conceput la diferite niv de abstractizare Orice sistem real poate fi reprezentat printr’o suita de modele 
PAGINA 5
 Ce este modelarea vizuala (2) ? Prin modelarea vizuala se pot abstractiza obiectele & logica proceselor de afaceri Prin modelarea vizuala poata fi analizata & proiectata o aplicatie (informatica)
PAGINA 6
Ce este UML? UML este prescurtarea de la Unified Modeling Language Definitie: limbaj de modelare pentru specificarea, vizuualizarea, constructia si documentarea componentelor unei aplicatii informatice UML reprezinta o sinteza a: Conceptele Data Modeling (Entity Relationship Diagrams) Business Modeling (work flow) Modelarea obiectelor Modelarea componentelor UML este limbajul standard “for visualizing, specifying, constructing, and documenting the artifacts of a software intensive system” [The UML definition was led by Grady Booch, Ivar Jacobson, and Jim Rumbaugh ], http://www.omg.org Focus pe elementele conceptuale si fizice ale reprezentarii unui sistem. 
PAGINA 7 
Istoria dezvoltarii UML 
PAGINA 8
 Conceptele UML UML poate fi utilizat pentru: Descrierea limitelor unui sistem si a functiilor sale principale (use cases & actori)  comportamentul functional al sistemului Ilustrarea implementarii cazurilor de utilizare prin diagramele de interactiuni Reprezentarea structurii statice a unui sistem prin diagrama de clase (utilizarea claselor+interfetelor pt model. entitatilor statice din sistem) si diagrama de obiecte (arata instantele claselor + legaturi) Modelarea evolutiei obiectelor prin diagrama de tranzitii Structurarea implementarii fizice a arhitecturii sistemului cu diagramele de componente si operationale  arata org. elementelor din sistem Diagrama de pachete: tip special de diagrame de clase; focus pe gruparea claselor Diagrama de activitati: descr flux de evolutie ale activitatilor Diagrama d secvente: surprinde tipul si ordinea mesajelor
PAGINA 9 
Arhitectura UML (1) Arhitectura = setul de decizii privind: i. Organizarea sistemului software. ii. Selectia elementelor structurale & interfete din care un sistem este format. iii. Evolutia & colaborarea elementelor. iv. Structura si evolutia elementelor. v. Arhitectura sistemului.
PAGINA 10 
Arhitectura UML (2) Use Case View Analiza Cazurilor de utilizare (CU) este o tehnica de “captura” a proceselor din perspectiva utilizatorului. Include evolutia “vazuta” de utilizatori, analisti si testatori. Specifica “fortele” ce influenteaza arhitectura. Aspectele statice sunt reprezentate in diagramele CU. Aspectele dinamice sunt reprezentate in diagramele de interactiuni, de activitati si de stari Design View Cuprinde clasele, interfetele si colaborarile ce definesc “vocabularul” unui sistem. Definesc necesitatile functionale ale sistemului. Aspectele statice sunt reprezentate in diagrama de clase si diagrama de obiecte 
PAGINA 11 
Arhitectura UML (3) Process View Defineste cozile si procesele concurentiale si de sincronizare. Reprezinta performanta si scalabilitatea. Aspecte statice si dinamice reprezentate la fel ca in Design View. Implementation View Defineste componentele si fisierele utilizate in realizarea unui sistem fizic. Reprezinta managementul configuratiei. Aspectele statice sunt reprezentate in diagrama de componente. Aspectele dinamice sunt redate in diagramele de interactiuni, de activitati si de stari. Deployment View Defineste nodurile ce formeaza topologia hardware. Reprezinta distributia si instalarea sistemului. Aspectele statice sunt reprezentate in diagrama de distributii. Aspectele dinamice sunt redate in diagramele de interactiuni, de activitati si de stari. 
PAGINA 12 
Arhitectura UML (4) Arhitectura structurata Meta-metamodel: limbaj specific metamodelului Metamodel: limbaj specific modelului Model: limbaj specific domeniului Obiecte: instante ale unui model 
PAGINA 13
 Arhitectura UML (5) Model sistemic Imagine de ansamblu = suma diagramelor UML 14 Metamodelul UML (1) 
PAGINA 15 
 Metamodelul UML (2)
PAGINA 16
 Metamodelul UML (3)
PAGINA 17 Metamodelul UML (4) 
PAGINA 18
 Elemente constructive in UML Lucruri Concept de modelare (elementul de individualitate). Relatii Leaga elementele individuale (I.e. conceptele) Diagrame Grupeaza colectiile organizate de elementele individuale (lucruri / relatii) 
PAGINA 19
 Lucruri - componente Structuri: “substantivul” modelelor UML Evolutii: componenta dinamica a modelelor UML Grupari: componenta organizationala a modelelor UML Adnotari: componenta explicativa a modelelor UML
 PAGINA 20 
Elemente conceptuale sau fizice Structuri 
PAGINA 21
 Clase (1) Din punct de vedere grafic, o clasa este redata ca un dreptunghi; Include in mod uzual numele clasei, atribute si operatii (in compartimente separate). Numele clasei este obligatoriu Atributul este numele propietatii unei clase; forma: attributeName: Type 
PAGINA 22
 Clase (2) Un atribut derivat poate fi calculat din alte atribute (el ne-existand in forma directa) d.e. varsta unei persoane poate fi calculata in raport de data nasterii si data curenta; reprezentare: / varsta: Date 
PAGINA 23
 Clase (3) Atributele pot fi: + public (permit accesul la date si metode din afara clasei) # protected (interzic accesul din afara clasei, dar il permit din clasele derivate) - private (interzic accesul la date si metode in afara clasei) / derived
PAGINA 24
 Clase (4) Vizibilitatea membrilor unei clase si reprezentarea in UML 
PAGINA 25 
Clase (4) Operatiile: descriu evolutia unei clase
PAGINA 26
 Descrie un set de operatii ce specifica evolutia obiectelor fara a descrie structura lor interna. Se reprezinta cu stereotipul <> in fata numelui Interfata Interfata nu poate fi instantiata Nu au atribute sau stari Pot specifica serviciile oferite de o clasa asociata 
PAGINA 27
 Vizibilitatea claselor in C++ 
PAGINA 28
 Relatii (1) Relatiile ofera o structura de comunicare intre obiecte Diagramele de secvente / colaborari sunt examinate pentru a determina ce legaturi trebuiesc stabilite intre obiecte pentru a permite evolutia sistemului; daca doua obiecte “vorbesc”, o legatura (link) trebuie sa existe intre ele. Tipuri de relatii: Dependenta – o clasa utilizeaza o alta clasa (“uses”) Asociere – o clasa este in relatie cu o alta clasa pe o durata mai mare de timp (“has a”) Generalizare Realizare – unul dintre elementele relatiei garanteaza finalizarea asteptatat din partea celuilalt element
PAGINA 29 
Relatii (2)
PAGINA 30
 Relatia de dependenta indica o relatie semantica intre doua sau mai multe elemente. O schimbare intr’unul din obiecte (independent, sursa) conduce la modificari semantice la celalalt obiect (dependent, destinatie) Dependenta (1) Orar Add(c:Course) Remove(c:Course) Curs 
PAGINA 31
 Caracteristici: Dependența semnifica „O clasă o folosește pe cealaltă” O relație de dependență indică faptul că o schimbare într-o clasă poate afecta clasa dependentă, dar nu neapărat si invers. O relație de dependență este adesea folosită pentru a arăta că o metodă are obiectul unei clase ca argument. Forme predefinite: Refine: “rafinarea” unui element de modelare prin intermediul altuia Trace: acelasi concept, dar pe un nivel de abstractizare diferit Use: relatia prin intermediul careia un element solicita prezenta unui alt element pentru buna sa desfasurare. Dependenta (2) 
PAGINA 32
 Dependenta – implementare in C++ class A { ... }; class B {public:void Executa1(void);}; void B::Executa1(void) {A a; a * a1 = new A; // ... delete a1;} B Executa A
PAGINA 33 
Generalizare (1) O relatie de generalizare / specializare leaga o subclasa de o superclasa. Indica o mostenire a atributelor si actiunilor de la nivelul superclasei la cel al subclasei (sau o specializare la nivelul subclasei a elementelor generale din superclasa) Reprezentare Persoana Student 
PAGINA 34
 Generalizare (2) UML permite ca o clasa sa mosteneasca mai multe superclase. Observatie: anumite limbaje OO (d.e. Java) nu permit mostenirea multipla Doctorand Angajat Asistent
PAGINA 35
 Generalizare (3) Mostenire multipla Avantaje: • Structurarea elementelor in diferite forme si cu diferite legaturi (ca in lumea reala) • Posibilitati multiplede utilizare a atributelor si operatiilor din clasele parinte Dezavantaje • Orice modificare la nivelul superclasei duce la modificari si in subclasa • Cand o subclasa mosteneste aceleasi attribute / operatii de la o superclasa, trebuie selectat cu grija ce va fi utilizat 
PAGINA 36
 Generalizare (4) Restrictii: Overlapping: un element apartine simultan la mai multe subclase Disjoint: contrar situatiei anterioare Complete: sunt specificate toate subclasele Incomplete: alte subclase pot sa apara ulterior
PAGINA 37
 Generalizare – implementare in C++ class Persoana{ ... }; class Student : public Persoana{ ... }; Persoana Student 
PAGINA 38
 Asociere Daca doua clase (in cadrul unui model) trebuie sa comunice una cu alta, trebuie sa existe o legatura (link) intre ele. Asocierea (delegarea) reprezinta o asemenea legatura. Reprezentare: sau Student FACULTATE Student FACULTATE invata la 
PAGINA 39
 Proprietatile asocierii Nume Numele asocierii Rol (nu mai exista in UML2; inlocuit cu “association end name”) Rolul specific al asocierii Multiplicitate Indica numarul de obiecte ce sunt conectate Tip Asociere, agregare, compozitie; Caz particular: asociere reflexiva (in obj aceleiasi clase) Directie Calificator: atribut / grup de atribute a caror valoare serveste pt partajarea ansamblului de obj. participante la o asociere 
PAGINA 40
 Asocierea - exemplu Profesor Curs * 1..* preda Nume relatie Multiplicitate (defineste numarul de obiecte asociate cu o instanta a asocierii Indicator de directie (cum se citeste numele relatiei) 
PAGINA 41
 Multiplicitatea O clasa poate fi legata de alta printr’o relatie:  One-to-one  One-to-many  One-to-one or more  One-to-zero or one  One-to-a bounded interval (one-to-two through twenty)  One-to-exactly n  One-to-a set of choices (one-to-five or eight) Exprimarea multiplicitatii:  Exact unu -1  Zero sau unu - 0..1  Multe - 0..* sau *  Unu sau mai multe - 1..*  Valoare exacta - d.e. 3..4 sau 6  Reprezentare complexa –d.e. 0..1, 3..4,6..* semnifica orice numar de obiecte, altul decat 2 sau 5 
PAGINA 42
 Asocierea reflexiva Asocierea a 2 instante ale aceleiasi clase O clasa are responsabilitati multiple:  d.e. angajatul unei firme poate fi seful unui grup format din 10 alti angajati. Angajat salariat manager coordoneaza 
PAGINA 43 
Multiplicitatea asocierilor (1) Multi-la-unu: o banca are mai multe ATM-uri; 1 ATM este legat doar la o banca Unu-la-multi: un inventator are mai multe inventii, o inventie este a unui singur inventator ATM Banca * 1 Inventator Inventie 1 * 
PAGINA 44 
Multiplicitatea asocierilor (2) O echipa de fotbal are 11 jucatori. Unul dintre ei este capitanul echipei. Un jucator poate juca numai intr’o echipa. Un capitan de echipa poate conduce o singura echipa. Jucator capitan membru al echipei conduce Echipa 10 1 11 1 1 0..1 membru al capitan 
PAGINA 45
 Asocieri duale Jucator Echipa 1 1..* liderul unei component al 1..* 1..* 
PAGINA 46
 Clasa unei asocieri Asocierile pot fi si obiecte in sine si reprezinta instantieri ale unor clase (link classes / association classes). Produs Garantie Certificat Model Serie_produs Numar_certificat 
PAGINA 47
 Asociere – agregare - compunere Agregarea defineste o relatie “parte– intreg”, in care “partea” poate exista in afara “intregului”. Este introdusa o relatie de tip: "has a". Compunerea este un tip special de agregare: intregul contine mai multe parti, iar partile nu pot exista in afara intregului. Elementele componente “traiesc” si “mor” odata cu intregul Facultate Student Corp uman Inima 
PAGINA 48
 Agregare – reprezentare in C++ class B { ... }; class A { private: A * a; }; Observatie: a este instantierea lui A A B
PAGINA 49
 Compozitie – reprezentare in C++ class B { ... }; class A { private: A a; }; Observatie: a este instantierea lui A A B 
PAGINA 50 
Exemple School Department 1 1..* Student 1..* * 
PAGINA 51 
O relatie semantica intre doua elemente, in care unul dintre elemente “garanteaza” finalizarea actiunilor asteptate din partea celuilalt element. Realizare Interfata: specifica operatiile vizibile ale unei clase / pachet fara a define si structura interna a acestora Realizarea este relatia ce leaga o clasa de interfata aferenta Observatie: in UML interfata este o clasa abstracta Realizare <> ControlPanel FunctiiSistem Implementeaza specifica 
PAGINA 52
 Exemple Faculty & student (asociere) Hospital & doctor (asociere) Door & Car (agregare) Member & Organization (agregare) People & student (generalizare) Circle & point (generalizare) Department & Faculty (asociere) Employee & Faculty (generalizare) Item & Printer (generalizare) 
PAGINA 53
 class A { public: virtual void Executa1(void) = 0; virtual int Executa2(void) = 0; }; class B : public A { public: virtual void Executa1(void); virtual int Executa2(void); }; void Bar::doSomething(void) {...}; Int Bar::doSomethingOther(void) {...}; Interfata – implementare in C++ <> A Executa1=0 Executa2:int=0 B Nu este realizabila in aceasta forma. Se poate implementa o clasa virtuala (fara atribute, fara metode private / protejate, fara implementari de metode) 
PAGINA 54
 Reguli generale Modelarea relatiilor Se utilizeaza dependentele daca relatiile nu sunt structurate (in alt mod). Se utilizeaza generalizarea in cazul unei relatii “is-a”. Nu se recomanda introducerea generalizarilor ciclice. Balance generalizations - Not too deep, not too wide. Trasarea unei relatii in UML Se vor folosi in special liniile drepte si cele oblice. Se va evita intersectia liniilor. Vor fi reprezentate doar relatiile necesare pentru o buna intelegere a unui grup de clase / obiecte. Se vor evita asocierile redundante.
1 M. Caramihai, © 2022 PROGRAMAREA ORIENTATA OBIECT 2
CURS 5
PAGINA 2
Introducere in UML (2)
PAGINA 3 
“A use case specifies the behavior of a system or a part of a system, and is a description of a set of sequences of actions, including variants, that a system performs to yield an observable result of value to an actor.” -The UML User Guide, [Booch,99] “An actor is an idealization of an external person, process, or thing interacting with a system, subsystem, or class. An actor characterizes the interactions that outside users may have with the system.” -The UML Reference Manual, [Rumbaugh,99] Cazuri de utilizare (CU) 
PAGINA 4 
Ce este un CU ? Un caz de utilizare este: Un set de scenarii ce descrie evolutia unui sistem impreuna cu utilizatorii sai Descrie functionalitatea pe care un sistem o pune la dispozitia utilizatorilor sai (oameni / sisteme) si a legaturilor dintre ei. Defineste necesitatile clientilor Actor: oameni / sisteme ce se gasesc in afara sistemului (interactioneaza cu sistemul) Scenariu: dialog intre actor si sistem 
PAGINA 5
 Scopul CU Descrierea cerintelor functionale ale sistemului Structurarea unui cadru de referinte comun Formarea bazei de testare si verificare Reprezentarea interactiunilor sistem-utilizator  Totalitatea CU: functionalitatea complete a sistemului Observatie: CU este initiat de catre un actor si descrie o suita de interactiuni dintre acesta si entitatea (informatica), interactiuni reprezentate printr’un schimb de mesaje 
PAGINA 6
 Identificarea CU Identificarea CU și apoi procesul de evolutie bazat pe scenarii se bazeaza pe intrebarea: ce valoare vizibilă externă și observabilă își dorește fiecare actor, de ex: Ce funcții își va dori actorul de la sistem ? Sistemul stochează informații? Ce actori vor crea, vor citi, vor actualiza sau vor șterge aceste informații? Este necesar ca sistemul să notifice un actor despre schimbările din starea internă? Există evenimente externe despre care trebuie să știe sistemul? Ce actor informează sistemul despre aceste evenimente? 
PAGINA 7
 Relatii intre CU Asociere: participarea unui actor la un CU Extensie: un CU poate fi extins cu un comportament definit de un alt CU Indică faptul că un caz de utilizare „Invalid password” poate include (sub rezerva specificarii în extensie) comportamentul specificat de cazul de utilizare de bază „Login account”. 
PAGINA 8
 Relatii intre CU Incluziune: o instanta a unui CU cuprinde si comportamentul specificat printr’un alt CU Când un caz de utilizare este descris ca utilizând funcționalitatea altui caz de utilizare, relația dintre cazurile de utilizare este denumită ca include sau use. Generalizare: Cazul de utilizare copil reprezinta o îmbunătățire a cazului de utilizare părinte. 
PAGINA 9 
CU - exemplu Actorii sunt conectati la cazurile de utilizare numai prin relatii de asociere. 
PAGINA 10
 Diagramele UML
PAGINA 11
 Diagrama de secvente (1)
PAGINA 12
 Diagrama de secvente (2) Diagrama de secvente este o diagrama de interactiuni care reda ordonarea in timp a mesajelor. Ea prezinta un set de obiecte si mesajele trimise si primite de acele obiecte. Din punct de vedere grafic, diagrama de secvente este un tabel ce prezinta obiectele pe orizontala si mesajele (ordonate in sensul parcuregerii timpului) pe verticala. Continut Obiecte: Schimba mesaje unul cu altul Mesaje: Sincrone: • Uzual: apel operație – se trimite mesajul și si se suspenda execuția în așteptarea răspunsului • reprezentate prin “sageata plina”; durata trebuie sa fie indicata prin bara de activare sau sageata de intoarcere 
PAGINA 13
 Diagrama de secvente (3) Asincrone: • Se trimite mesajul și si se continua imediat fără a aștepta valoarea returnată • reprezentata prin “jumatate de sageata” Pot exista mesaje de tip «create» si«destroy» Tipuri speciale Lost message: mesajul nu ajunge niciodata la destinatie (d.e. ping) Found message: mesajul a carui origine nu este cunoscuta (d.e. exception handling) 
PAGINA 14
 Reprezentare Un obiect este redat ca o cutie din care coboara o linie intrerupta. Linia poarta numele de linia de viata a obiectului (reprezinta durata de viata a unui obiect pe un anumit interval de timp). Mesajele sunt redate cu sageti orizontale (“coboara” odata cu trecerea timpului) Conditiile ( d.e. [check = “true”] ) indica faptul ca un mesaj a fost transmis. Ordinea obiectelor nu este semnificativa Un indicator de iteratie (d.e. * sau [i = 1..n] , indica faptul ca un mesaj va fi repetat de mai multe ori (corespunzator valorii precizate) 
PAGINA 15
 Diagrama de secvente - observatii Diagramade secvente reprezinta evolutia sistemului in raport cu interactiunile. Reprezinta o complementaritate a diagramei de clase (care reprezinta structura sistemului informatic) Foarte utila in identificarea obiectelor implicate in diverse activitati. Buget mare de timp pentru implementare. Principiul de realizare: KISS (Keep It Small & Simple) 
PAGINA 16
 Diagrama de activitati (1) 
PAGINA 17 
Diagrama de activitati (2) Diagrama de activitati (DA) este un flowchart si indica fluxul de control de la o activitate la alta. Diagrama de activitati specifica, dezvolta si documenteaza dinamica unei “societati de obiecte” Diagrama de interactiuni descrie fluxul de control de la un obiect la altul; diagrama de activitati descrie fluxul de control de la o activitate la alta. Exista doua feluri de stari: Actiuni (Action state): • Nu pot fi descompuse • Sunt “instantanee” (in raport cu nivelul de abstractizare din model) Activitati (Activity state): • Pot fi descompuse • Activitatea este modelata de o alta diagrama de activitati 
PAGINA 18
 Diagrama de activitati (2) Utilizari: Identificare cazuri de utilizare candidate, prin examinarea fluxurilor de lucru în afaceri Identificare condițiile pre- și post (contextual) pentru cazurile de utilizare Modelare fluxuri de lucru între/în cadrul cazurilor de utilizare Modelare fluxuri de lucru complexe în operațiuni pe obiecte Modelare în detaliu activități complexe într-o activitate de nivel înalt
PAGINA 19
 Caracteristici Seamana foarte mult cu diagramele clasice Identifica activitatile din cadrul unui sistem (si se bazeaza pe cazurile de utilizare) Identifica tranzitiile intre activitati Descrie comportamentul unei clase ca raspuns la calculele interne. Orientata mai mult catre business process decat catre OO Foarte utila in faza de testare Diagrama de activitati descrie fluxul din interiorul unui system Diagrama de activitati este un caz special al diagramei de stari in care starile sunt inlocuite cu activitati (functii).
PAGINA 20
 Notatii 
PAGINA 21
 Exemplu © www.developer.com 
PAGINA 22
 Diagrama de colaborari (1)
PAGINA 23 
Diagrama de colaborari (2) Prezinta modul in care obiectele interactioneaza unele cu altele (tinand cont de unitatile organizationale) Secventa de mesaje este determinata prin numere: 1, 2, 3, 4, ….. 1, 1.1, 1.2, 1.3, 2, 2.1, 2.1.1, 2.2, 3 (prezinta modul in care o operatie apeleaza o alta operatie) Observatie: DC – Diagrama de comunicare (in UML2) Continut Obiecte • Schimba mesaje unele cu altele Mesaje • Sincrone: reprezentate prin sageata completa • Asincrone: “semnale” reprezentate prin sageata incompleta • Mesaje de tip «create» sau «destroy» • Mesajele sunt numerotate si pot avea “bucle”
PAGINA 24 
Exemple © www.dotnetcoders.com 
PAGINA 25 Comparatie DC / DS Reprezentarea diagramei de colaborari prezinta conexiunea dintre obiecte. Diagrama de secvente permite o buna reprezentare a fluxului de timp Secventa de mesaje este mai greu de inteles intr’o diagrama de colaborari Organizarea obiectelor (si fluxul de control) sunt cel mai bine identificate in diagrama de colaborari Observatii: Controlul complex este greu de reprezentat printr’o singura diagrama!!! Diagrama de colaborari este mai des folosita decat cea de secvente 
PAGINA 26 
Sumar 1. Diagrama CU [Model Functional] modeleaza functionalitatea dpdv user 2. Diagrama de clase [Model Obiectual] modeleaza structura sisemului utilizand obiecte 3. Diagrama de interactiuni [Model Dinamic] (secvente & colaborari) modeleaza mesajele schimbate intre obiecte 4. Diagrama de stari [Model Dinamic] modeleaza tranzitiile intre stari 5. Diagrama de activitati [Model Dinamic] modeleaza fluxul de control (ca tranzitie intre activitati) 
PAGINA 27 
Sisteme de dimensiuni mari Principiul Roman: Divide & impera Sistemele mari trebuiesc desfacute in componente mai mici, pentru a putea fi mai usor gestionate Metode structurale: descompunere functionala In OO: gruparea claselor in unitati cu caracteristici comune. Pachete (Packages) (conceptual: in momentul dezvoltarii sistemului) Componente (fizic: in momentul rularii) Diagrama de pachete poate fi folosită pentru a simplifica diagramele de clase complexe (i.e. poate grupa clase în pachete) Un pachet reprezinta o colecție de elemente UML legate logic. 
PAGINA 28
 Pachete (Packages) Un pachet reprezinta o “grupare” de elemente de modelare; poate contine clase sau alte pachete / diagrame 
PAGINA 29
 Elemente Nume (string) Simple Calificator: numele P are ca prefix numele P in care se gaseste, d.e. Pachet1::Pachet2 Componenta: un P poate contine diferite elemente (d.e. clase interfete, diagrame, alte pachete, etc) Observatii: • daca un P este distrus, sunt distruse si toate componentele sale • Orice alement apartine unui singur P • P se recomanda a fi pe max 2-3 nivele Vizibilitate: idem ca la clase (usual: public) 
PAGINA 30
 Pachete - exemple Vanzari Client Ordin Depozit Locatie Item Stoc Ordin 
PAGINA 31
 Pachete – caracterizare Un pachet poate contine diferite tipuri de elemente de modelare Pot fi incluse si alte pachete in vederea dezvoltarii de ierarhii. Un pachet defineste un “spatiu” pentru elementele ce le contine (similar cu directoarele din DOS / Windows) Pachetele sunt utilizate in general ca structuri de grupare a unor elemente cu o semantica comuna. Diagrama prezinta o “vedere de sus” asupra sistemului. 
PAGINA 32
 Concepte de baza Package Grup de elemente de modelare. Import Relatie de dependenta; indica faptul ca elementele de continut ale pachetului tinta sunt adaugate spatiului pachetului sursa (extinde spatial de lucru al P importator) Access Relatie de dependenta; indica faptul ca elementele de continut ale pachetului tinta pot fi accesate in raport cu spatiul pachetului sursa (permite utilizarea elementelor dintr’un alt P prin specificarea caii de acces la acestea). Nume <> <> 
PAGINA 33
 Concepte de baza Package Import Un pachet importa functionalitatile celuilalt pachet Access Un pachet necesita un “ajutor” din partea celuilalt pachet pentru a functiona 
PAGINA 34
 Relatii intre pachete – exemplu
PAGINA 35
 Mostenirea Un pachet aflat in relatie de generalizare cu un alt pachet va mosteni elementele publice / protejate ale acestuia daca: Elementele apartin pachetului de la nivelul ierarhic superior Elementele sunt importate de catre pachetul de la nivelul ierarhic superior 
PAGINA 36
 Reprezentarea pachetelor (continut ) Pachetele sunt reprezentate prin intermediul diagramelor statice Exista doua modalitati echivalente de reprezentare:
PAGINA 37
 Utilizarea pachetelor Cerinte Grd cat mai inalt de coeziune interna Nivel cat mai redus de cuplare externa Unitatea scopului Utilizari Crearea unei “vederi de ansamblu” asupra unui mare numar de elemente de modelare Organizarea modelelor de mari dimensiuni Gruparea elementelor interconectate Separarea spatiilor de lucru 
PAGINA 38 
Pachete – reguli de configurare Elementele de modelare puternic cuplate trebuie sa se gaseasca in acelasi pachet Elementele de modelare slab cuplate trebuie sa se gaseasca in pachete diferite. Trebuisc evitate relatiile (in special asocierile) dintre elementele de modelare aflate in pachete diferite. Un element importat intr’un pachet nu trebuie sa “cunoasca” cum este folosit in acel pachet. 
PAGINA 39
 Sisteme & subsisteme Sisteme: un set e elemente de organizare utilizate in vederea implementarii unui scop Legatura dintre sisteme si subsisteme este de tip compozitie. Arhitecturi C/S Structuri monolitice Pe 2 nivele Pe 3 nivele 
PAGINA 40
 Subsisteme Subsistemele sunt utilizate in descompunerea sistemelor. Grup de elemente de modelare ce formeaza impreuna o unitate de comportament in sistem fizic 
PAGINA 41 
Subsistem – exemplu Un sistem poate fi format din subsisteme ce comunica intre ele. Interconectare: prin utilizarea unui subsistem la nivel interfata pentru reducerea interdependentelor SS2 SS3 SS1
PAGINA 42
 Concepte de baza Subsistem Un grup de elemente de modelare ce reprezinta o unitate de evolutie intr’un sistem fizic. Subsistemele se definesc dpdv: functional, logic si avand coeziune fizica 
PAGINA 43 
Subsisteme – componente Un subsistem are doua componente: O componenta externa – prezinta serviciile furnizate de subsistem (i.e. specificare ) O componenta interna – prezinta configurarea subsistemului (i.e. realizare ) Exista o mapare intre cele doua componente. 
PAGINA 44
 Caracteristicile subsistemelor Un subsistem are elemente de specificare, respectiv de realizare pentru a putea implementa cele doua componente ale sale Operatii Elemente de specificare Elemente de realizare
PAGINA 45
 Elemente de realizare Elementele de realizare definesc continutul actual al subsistemului.  Elementele de realizare consta in: •Clase si relatiile dintre ele •Ierarhii de subsisteme 
PAGINA 46 
Elemente de specificare (1) Elementele de specificare definesc vizibilitatea externa a subsistemului 
PAGINA 47
 Elementele de specificare: Descriu serviciile oferite de subsistem Descriu evolutia exterioara a subsistemului Nu dau nici o informatie despre structura interna a subsistemului Descriu interfata subsistemului Elemente de specificare (2)
PAGINA 48
 Cand se utilizeaza subsistemele ? Descompunerea sistemelor mari in module / componente mai mici Dezvoltarea sistemelor distribuite Asamblarea unui set de module intr’un sistem de dimensiuni mai mari Dezvoltarea sistemelor bazate pe structuri multiple 
PAGINA 49 
Subsisteme – reguli de configurare Un subsistem se defineste pentru fiece parte a unui sistem de mari dimensiuni Specificatiile tehnice sunt dependente de tipul sistemului / subsistemului Fiece subsistem trebuie sa fie proiectat in mod independent 
PAGINA 50
 Modele Un model surprinde o “vedere” asupra unui sistem si incearca o “descriere” completa a acestuia In UML 2.5 nu este foarte consistenta definirea domeniului de aplicare a modelului. Într’un loc se spune că un model surprinde un view a unui sistem fizic, în timp ce în altul - acel sistem este înțeles în sensul cel mai larg și poate include nu numai software și hardware, ci și organizații și procese. 
PAGINA 51
 Concepte de baza Model O viziune asupra unui sistem, intr’un anumit scop, in vederea determinarii aspectelor semnificative ale sistemului Trace O conexiune intre elementele de modelare care caracterizeaza acelasi concept in raport cu mai multe modele. (nu exista o relatie directa intre modele ci doar relatii de tip “trace” intre elementele diferitelor modele) <> 
PAGINA 52
 Trace Este un stereotip al relatiei de dependenta Nu se aplica elementelor ce apartin aceluiasi model Reprezinta (generic) o dependență ce indică o relație istorică sau de proces între două elemente ce reprezintă același concept fără reguli specifice pentru derivarea unuia din celălalt.
PAGINA 53
 Modele vs. diagrame Diagramele specifica detaliile tehnice ale unui model. 
PAGINA 54 
Utilizarea modelelor Modelele se folosesc pentru: A oferi diferite “viziuni” asupra sistemului pentru categorii diferite de utilizatori A sublinia diversele aspecte ref. evolutia sistemului in timp A evidentia diversele etape de evolutie a unui sistem informatic
1 M. Caramihai, © 2022 PROGRAMAREA ORIENTATA OBIECT 2
CURS 6
PAGINA 2

Alte limbaje vizuale (UML vs. SysML, BPMN, IDEF) 
PAGINA 3
 SysML 
PAGINA 4 
Modul de descriere a sistemelor Specificatii Interfata Proiectare sistem Analiza & implementare Testare Trecerea de la “modelul documentar” la “modelul sistemic” Inainte In viitor 
PAGINA 5
 Ce este SysML (1) ? Un limbaj de modelare vizuala – raspuns la UML for Systems Engineering RFP dezvoltat OMG, INCOSE, si AP233. adoptat de OMG in Iunie 2006 Suporta specificarea, analiza, proiectarea, verificarea si validarea sistemelor (in sens general): se include hardware, software, date, personal, proceduri si facilitati Suporta modelarea si schimbul de date prin intermediul standardului XMI ® (XML Metadata Interchange) 
PAGINA 6
 Este un limbaj de modelare vizuala care ofera: Semantica = intelegerea conceptelor Notatii= reprezentarea conceptelor Nu este o metodologie sau un instrument: SysML este independent de orice limbaj de programare UML – Software Engineering SysML – System Engineering Ce este SysML (2)?
PAGINA 7
 SysML - Concepte Modelarea sistemelor trebuie sa permita integrarea tuturor elementelor aferente acestora. SysML (Systems Modeling Language) este un limbaj de modelare al aplicatiilor din ingineria de sistem. Suporta specificarea, analiza, designul, verificarea si validarea unei game vaste de sisteme si sisteme de sisteme. Aceste sisteme pot include hardware, software, informatii, procese si facilitati. Ofera posibilitatea de a unifica concepte inrudite software si non-software, astfel umpland distanta ce se afla intre ele. 
PAGINA 8 
Reprezentarea unui “sistem de sisteme”
PAGINA 9
Modelarea nivelelor ierarhice Operational Models System Models Component Models

PAGINA 10
Modelarea comunicarii intre sisteme Testatori Dezvoltatori / integratori Clienti Director proiect Reglari Testatori, Vanzatori
PAGINA 11
Legaturile intre SysML si UML
PAGINA 12
SysML – Pozitionare SO 10303/AP-233 NEUTRAL SE DATA EXCHANGE FORMAT Electrical CAE Mechanical CAD SW Dev Environment Systems Engineering Engineering Analysis Testing Tools Planning Tools Algorithm Design S
PAGINA 13
Taxonomia SysML
PAGINA 14
Blocuri (1) Blocurile sunt elementele structurale de baza (similare cu clasele din UML implica modelarea blocurilor in loc de modelarea claselor si furnizeaza un vocabular mai potrivit pentru ingineria sistemelor. Un bloc cuprinde software, hardware, date, procese, personal si facilitati. Prezinta un concept unificator de descriere a structurii unui element / sistem Sistem Hardware Software Date Proceduri Facilitati Persoane «block» BrakeModulator allocatedFrom «activity»Modulate BrakingForce values DutyCycle : Percentage
PAGINA 15
Blocuri (2) Pot exista mai multe “compartimente” ce pot descrie caracteristicile unui bloc: Proprietati Operatii Constrangeri Necesitati indeplinite in cadrul blocului Compartimente definite de useri In SysML se face modelarea blocurilor in loc de modelarea claselor si se furnizeaza un vocabular mai potrivit pentru ingineria sistemelor
PAGINA 16
Tipuri de proprietati (1) Proprietatea reprezinta o caracteristica structurala a unui bloc: Proprietati de compozitie • Utilizarea unui bloc in contextul unui alt bloc (bloc component) • Exemplu - elicea Proprietati de referinta • O parte a unui bloc ce nu este in componenta blocului inclus (non compozitie) • Exemplu – agregarea unor componente intr’un subsistem logic
PAGINA 17
Tipuri de proprietati (2) Proprietate de valoare O proprietate cuantificabila (i.e. unitati, dimensiuni sau distributii de probabilitate) Exemplu • Valoare ne-distribuita: tirePressure:psi=30 • Valoare distribuita: «uniform» {min=28,max=32} tirePressure:psi
PAGINA 18
Utilizarea blocurilor Se bazeaza pe diagrama de clase UML Suporta caracteristici speciale Diagrama de blocuri descrie relatiile dintre acestea (compozitie, asociere, specializare) Diagramele interne de blocuri descriu structura interna a acestora prin intermediul proprietatilor asociate si a conexiunilor Blocurile pot fi caracterizate prin evolutie Blocurile sunt utilizate pentru specificarea ierarhiilor si interconexiunilor
PAGINA 19
Exemplu
PAGINA 20
Exemplu Blocurile sunt reprezentate sub forma de clase UML. Blocul principal defineste distilatorul, alcatuit la randul lui din trei tipuri de blocuri: o Un bloc pentru condensarea vaporilor o Un boiler care are rolul de evaporator (multiplicitatea indica ca doua boilere vor fi folosite) o O valva care are rolul de scurgere Aceste blocuri apartin fizic blocului principal, de aceea asocierile din diagrama sunt compozitii reprezentate printr’un romb plin. Daca un bloc ar fi facut parte din blocul principal, dar nu ar fi apartinut fizic acestuia, ar fi fost numit referinta si ar fi fost reprezentat printr’un romb gol. “Flow port” este o definitie noua a SysML. Acestea marcheaza ce poate trece (in/out) printr’un bloc, indiferent daca este vorba de date, materie sau energie. Diagrama de mai sus arata ca blocul distilatorului primeste ca intrari apa rece si caldura externa.
PAGINA 21	
Definire blocuri vs. utilizare blocuri Definitie Blocul cuprinde o definitie Prezinta proprietati, etc. Reutilizare in contexte multiple Utilizare O parte a unui bloc este utilizata in cadrul unui alt bloc Identic cu “rolul” Diagrama definire blocuri Diagrama interna (de blocuri)
PAGINA 22
Diagrama Interna de Blocuri (DIB) Bloc inclus Conector Port Flux DIB specifica interconexiunea partilor Componenta
PAGINA 23
Exemplu
PAGINA 24
 Exemplu Blocul distilatorului a fost copiat din diagrama de definire a blocurilor Blocurile componente specificate in diagrama de definire a blocurilor au fost instantiate ca parti in diagrama interna a blocurilor si sunt denumite astfel:”rol:numele blocului [multiplicitate]”. Multiplicitatea specificata in Diagrama de definire a blocurilor este consecventa cu cea a componentelor din Diagrama interna a blocurilor unde este reprezentata in componenta prin paranteze patrate. Unde multiplicitatea nu este reprezentata se considera ca multiplicitate implicita 1. Porturile blocului principal sunt asociate cu porturi ale componentelor interne prin conectori. De exemplu apa rece care intra in distilator alimenteaza blocul de condensare. “Flow port” are o proprietate de directie care poate fi definita ca intrare, iesire, intrare/iesire.
PAGINA 25
Porturi SysML Specifica punctele de interactiuni intre blocuri si partile componente Integreza structura cu evolutia portName:TypeName Tipuri de porturi Port Standard (UML) • Specifica un set de operatii / semnale necesare sau oferite de bloc • Se specifica la nivelul interfetei UML Port de flux • Specifica fluxul de intrare / iesire dintr’un bloc (sau dintr’o componenta a acestuia) Porturile standard si porturile de flux suporta concepte diferite de interfata
PAGINA 26
Notarea porturilor Port Standard Port de flux interfata oferita (ofera operatii) Interfata necesara (apelare operatiuni) item de flux
PAGINA 27
Diagrame de evolutie
PAGINA 28
Activitati Activitatile specifica transformarile intrarilor in iesiri prin intermediul unei secvente controlate de actiuni. Extensii SysML (ref. activitati): Suport pentru modelarea (continua a) fluxurilor Alinierea activitatilor la Enhanced Functional Flow Block Diagram Diagrama de activitate reprezinta pasii unui proces, de multe ori folosindu-se de „pini de iesire sau de intrare” care corespund tipului de element cerut ca intrarea unei activitati respectiv elementul generat ca o iesire. Daca o actiune sau activitate corespunde unei operatii de bloc, se poate asigura ca tipurile intrarii si iesirii acestei operatii sunt consecvente cu tipurile operatiei de bloc. Toate definitiile diagramei de activitate din UML sunt valabile si in SysML.
PAGINA 29
Diagrama de activitati (DA) Activitate Action Intrare Iesire Intrare DA specifica o secventa controlata de activitati
PAGINA 30
Reprezentari Nod initial Nod final de activitate Nod final de flux Nod de rascruce Nod Join Nod de decizie Nod de combinare
PAGINA 31
Descompunerea activitatilor Definire Utilizare 1 : Detect Loss of Traction p1 : TractLoss a2 : Modulate Braking Force p2 : TractLoss
PAGINA 32
Interactiuni Diagrama de secvente (DS) reprezinta evolutia in timp a succesiunii de mesaje Reprezentarea fluxului de control Descrierea interactiunii dintre parti DS ofera mecanisme de reprezentarea a diverse tipuri de scenarii: secvente control logic Etc. SysML nu include timing, interactiuni sau diagrame de comunicatii
PAGINA 33
Exemplu (pornire vehicul) Interactiuni Black Box StartVehicleBlackBox driver:Driver vehicle:HybridSUV ref StartVehicleWhiteBox 1: StartVehicle turnIgnitionToStar
PAGINA 34
Exemplu (pornire vehicul) sd StartVehicleWhiteBox ecu:PowerControlUnit epc:ElectricalPowerController 1.1: Enable 1: StartVehicle 1.2:ready
PAGINA 35
Operatori de interactiune (1) ref name Referinta la un fragment de DS definita in alt loc opt [condition] O componenta va fi executata in functie de o conditie / valoare de stare alt Are 2 sau mai multe componente; doar una va fi executatat in functie de o conditie / valoare de stare Un bloc de functii va fi executat (eticheta [else]) daca nu exista nici o alta conditie care sa fie indeplinita.
PAGINA 36
Operatori de interactiune (2) par Contine 2 componente ce se executa concurential: • Concurenta NU impune simultaneitate; pur si simplu ordinea nu poate fi determinata: (A then B), (B then A), sau (A and B interleaving) … loop min..max [escape] Are un numar min de executii, (optional) un numar maxim de executii si (optional) o conditie de iesire break [condition] Conditie de iesire: daca este adevarata, continutul este executat, pana la instructiune; restul nju mai este executat
PAGINA 37
Operatori de interactiune (3) critical In DS exista o regiune critica. Regiunea este considerata a fi atomica. neg Fragmentul din DS este interzisa. consider (list of messages) ignore (list of messages) Luate in considerare: Sunt listate mesajele relevante din secventa Ignorate: Sunt listate mesajele care “ajung” dar nu sunt “interesante” dpdv al aplicatiei
PAGINA 38
Operatori de interactiune (3) critical In DS exista o regiune critica. Regiunea este considerata a fi atomica. neg Fragmentul din DS este interzisa. consider (list of messages) ignore (list of messages) Luate in considerare: Sunt listate mesajele relevante din secventa Ignorate: Sunt listate mesajele care “ajung” dar nu sunt “interesante” dpdv al aplicatiei
PAGINA 39
Exemplu ucHSUV_UseCases [Operational Use Cases] HybridSUV Driver Accelerate Drive_The_Vehi cle Steer Brake Park
PAGINA 40
Diagrama de necesitati Alocari Cerinte
PAGINA 41
Alocari Reprezinta acel tip de relatii ce mapeaza un element (apartinand unui model) cu un altul (dintr’un alt model) Tipuri de alocari: Evolutiv (i.e., functie  component) Structural (i.e., logic  fizic) Software  Hardware …
PAGINA 42
Cerinte Stereotipul «requirement» reprezinta o solicitare de tip text: Include id si proprietatile textului Pot fi adaugate proprietati definite de utilizator (d.e. metode de verificare) Pot fi adaugate categorii definite de utilizator (d.e. functional, interface, performanta) Ierarhia de cerinte descrie cerintele continute intr’o specificatie Relatiile dintr’o diagrama de cerinte include: DeriveReqt, Satisfy, Verify, Refine, Trace, Copy
PAGINA 43
Stereotypes Definire Stereotip Aplicare Stereotip «metaclass» NamedElement «stereotype» ConfigurationItem author: String version: String lastChanged: Date «configurationItem» Engine author=”John Doe” version=”1.2" lastChanged=Dec12, 2005
PAGINA 44
Exemplu de aplicatie integrate
PAGINA 45
UML vs SySML (1) UML DIAGRAMA SYSML SCOP DIAGRAMA UML ANALOG Diagrama de activitate (Activity diagram) Arata comportamentul sistemului, cum controlul si datele decurg. Folositor la analiza functionala. Compara diagrame de blocare al fluxului extins functional Extended Functional Flow Block diagrams (EFFBDs), deja des folosite printre inginerii de sistem. Diagrama de activitate (Activity diagram) Diagrama de definire a blocurilor (Block Definition diagram) Arata structura sistemului in componente cu proprietatile, operatiile si relatiile lor. Folositoare pentru analiza si designul sistemului. Diagrama de clasa (Class diagram) Diagrama de blocuri interne (Internal Block diagram) Arata structura interna a componentelor, incluzand partile si conectorii lor. Folositoare pentru analiza si designul sistemului. Diagrama de structuri compuse (Composite Structure diagram) Diagrama pachet (Package diagram) Arata organizarea in pachete, vizualizari si puncte de vedere a unui model. Folositor pentru managementul modelului. Diagrama pachet (Package diagram)
PAGINA 46
UML vs SySML (2) DIAGRAMA SYSML SCOP DIAGRAMA UML Diagrama parametrica (Parametric diagram) Arata constrangerile parametrice dintre elementele structurale. Folositoare la analiza performantei si analiza cantitativa. N/A Diagrama cerinta (Requirement diagram) Arata necesitatile sistemului si relatiile lor cu alte elemnte. Folositoare la ingineria necesitatilor. N/A Diagrama secventa (Sequence diagram) Arata comportarea sistemului ca si interactiuni intre componentele sistemului. Folositoare la analiza sistemului si design Diagrama secventa (Sequence diagram) Diagrama de stare al masinii (State Machine diagram) Arata comportamentul sistemului ca o secventa de stari pe care o componenta sau o actiune o cunoaste ca raspuns unor actiuni. Folositoare la designul sistemului si generarea simularii/codului. Diagrama de stare al masinii (State Machine diagram)
PAGINA 47
UML vs SySML (3) DIAGRAMA SYSML SCOP DIAGRAMA UML Diagrama cazurilor de utilizare (Use Case diagram) Arata cerintele functionarii sistemului ca tranzactii care sunt semnificative pentru folositorii sistemului. Folositoare la specificarea cerintelor functionalitatii. Diagrama cazurilor de utilizare (Use Case diagram) Tabele de alocare * (Allocation tables) *tabele derivate dinamic, nu sunt chiar diagrame Arata diferite tipuri de alocari (ex. alocari necesare, alocari functionale, alocari structurale). Folositoare pentru facilitarea verificarii si validarii automatizate (V&V) si analize de lipsuri. N/A N/A Diagrama de componente (Component diagram) N/A Diagrama de comunicare (Communication diagram)
PAGINA 48
UML vs SySML (4) DIAGRAMA SYSML SCOP DIAGRAMA UML N/A Diagrama de desfasurare (Deployment diagram) N/A Diagrama de privire generala asupra interactiunilor (Interaction overview diagram) N/A Diagrama de obiecte (Object diagram) N/A Diagrama de timp (Timing diagram)
PAGINA 49
Concluzii – relatia SysML / UML UML este un “General Purpose Modeling Language (GPML)”, in timp ce SysML este un “Domain-Specific Modeling Language (DSML)” fiind definit ca o personalizare a lui UML 2.0 Avantaje: reutilizarea semanticii si notatiilor din UML 2.0 SysML personalizeaza mai bine semantica din ingineria sistemelor (prin adaugarea de doua noi diagrame: Requirement Diagrams si Parametric Diagrams) SysML este “mai mic” dpdv al numarului de diagrame (9 vs. 13) Dezavantaj: mosteneste multe din problemele din UML (d.e. Complexitatea notatiilor si semantica)
PAGINA 50
BPMN
PAGINA 51
Modelare BPMN  BPMN reprezinta o notatie grafica (standard) menita sa defineasca procesele de afaceri dintrun workflow Colectie de activitati inrudite ce produce un anumit produs sau serviciu pentru un anumit client Proces de afaceri Secvente de operatii. Abstractizarea unei activitati concrete. Sablon de activitate incapsulat intr-un process in vederea integrarii acestuia in sistem Workflow
PAGINA 52
Modelare BPMN În cadrul diagramelor BPMN, etapele de modelare a unui proces sunt asemănătoare cu cele ale modelării unui proces folosind diagrama de activități UML. Există, totuși, o serie de bune practici în cadrul modelării BPMN care privesc atât etape de definire a procesului, dar și de redactare a diagramei. 1. Scopul procesului 2. Aspectul diagramei 3. Structura procesului
PAGINA 53
Modelare BPMN Flow Objects: evenimente, activități, porți Connecting Objects: flux de secvență, flux de mesaje, asociere Swimlanes: piscină sau bandă Artefacte: obiect de date, grup, adnotare Modelare de tip BPMN este o metodă de diagramă de flux ce modelează pașii unui proces (de afaceri) planificat de la un capăt la altul. Descrie vizual o secvență detaliată a activităților și a fluxurilor de informații necesare pentru a finaliza un proces. BPMN începe și se termină cu diagrama fluxului procesului. Aceasta reprezinta o hartă tehnică a fluxului și practicilor unei organizații, prezentată într’un limbaj standardizat și disponibilă pentru îmbunătățire, distribuire și urmărire de către utilizatori.
PAGINA 54
Flow Objects Evenimente: Un declanșator care pornește, modifică sau finalizează un proces. Activitate: O anumită activitate sau sarcină efectuată de o persoană sau de un sistem. Poarta de acces (Gateway): Punct de decizie care poate ajusta calea în funcție de condiții sau evenimente.
PAGINA 55
Connecting Objects 55 Fluxul secvențial: Afișează ordinea activităților de efectuat. Este afișat ca o linie dreaptă cu o săgeată. Poate afișa un flux condiționat sau un flux implicit. Fluxul de mesaje: Înfățișează mesajele care curg prin „pool” sau granițele organizației, cum ar fi departamentele. Este reprezentat de o linie întreruptă cu un cerc la început și o săgeată la sfârșit. Asociere: Afișat cu o linie punctată, asociază un artefact sau un text unui eveniment, activitate sau gateway.
PAGINA 56
Artefacte Informații suplimentare pe care dezvoltatorii le adaugă pentru a aduce un nivel necesar de detaliu diagramei. Există trei tipuri de artefacte: obiect de date, grup sau adnotare. Un obiect de date arată ce date sunt necesare pentru o activitate. Un grup arată o grupare logică a activităților, dar nu modifică fluxul diagramei. O adnotare oferă explicații suplimentare unei părți a diagramei.
PAGINA 57
Exemplu
PAGINA 58
Modelare BPMN Strengths – Puncte tari Weaknesses – Puncte slabe  notare standardizată ISO număr mare de elemente capacitatea de a modela diferite tipuri de procese  un număr mare de instrumente de sprijin pentru modelarea și gestionarea proceselor de afaceri  suport industrial bun schema xml standardizată  capabil de a fi executat  capacitatea de a fi extins și adaptat complexitatea specificației (peste 500 de pagini)  complexitatea notației (peste 100 de elemente vizuale)  interoperabilitate slabă între instrumentele BPMN
PAGINA 59
BPMN vs UML UML este un limbaj de modelare orientat pe obiecte, care utilizează o metodă orientată pe obiecte pentru a modela aplicațiile. UML se concentrează pe limbaje standard, mai degrabă decât pe procese standard. Notația UML își propune să dezvolte un meta-model universal și ușor de implementat, care poate unifica semantica și poate construi o notație universală. Pe de altă parte, BPMN adoptă o metodă orientată spre proces pentru a modela sistemul. Domenii de aplicare diferite: UML se adresează în primul rând persoanelor care modelează și construiesc sisteme software precum aplicații web și medii cloud. UML permite documentarea unui design care poate fi implementat într’o varietate de limbaje de programare. BPMN se concentrează pe proiectarea modelelor de proces „așa cum sunt” și „a fi” și este utilizat deopotrivă de analiștii de afaceri, dezvoltatorii IT și oamenii de afaceri. Nu este folosit doar pentru proiectarea și îmbunătățirea sistemelor noi, ci permite și îmbunătățirea proceselor manuale. Principala diferență dintre UML și BPMN o reprezinta diferența de perspectivă: UML este orientat pe obiecte, iar BPMN este orientat pe proces. Acest lucru face ca BPMN să fie aplicabil pe scară largă atât in IT, cât și in procese de afaceri, în timp ce UML este mai potrivit pentru dezvoltarea sistemelor IT și mai puțin potrivit pentru îmbunătățirea sistemelor de procese
PAGINA 60
IDEF
PAGINA 61
Limbajul IDEF IDEF reprezintă o serie de limbaje de modelare concepute inițial pentru a fi utilizate în domeniul ingineriei software. Notațiile de modelare IDEF au fost concepute pentru a modela entitățile dintr-o întreprindere cu scopul de a avea o imagine abstractă utilă a diferitelor puncte de vedere (punctul de vedere al funcției și punctul de vedere al informației). IDEF0 și IDEF3 sunt cele mai potrivite pentru modelarea proceselor
PAGINA 62
IDEF0 folosește casete, săgeți și text pentru a comunica procedura de desfășurare a unui proces. identifica relațiile dintre activități și ofera o vedere a tuturor proceselor dintr’un sistem. Sagetile poarta denumirea de ICOM. IDEF0 este un set de activități ce preia anumite intrări și, utilizând un anumit mecanism, și supus unor controale, transformă intrările în ieșiri.
PAGINA 63
Exemplu
PAGINA 64
IDEF1 Principalele concepte IDEF1 sunt: • entitate: informațiile disponibile într-o organizație despre obiecte fizice sau conceptuale (oameni, idei etc.). Entitatea este înțeleasă ca o imagine informațională. • relații: asociere între entități (adică imagini informaționale). • clase de entitate și relație: șabloane pentru entitate și relație
PAGINA 65
IDEF1x Elementele de bază ale IDEF1x sunt entitatea (care se referă la o colecție), atributul (asociat fiecărui membru al mulțimii) și structura de clasificare (pentru modelarea tipurilor de date logice). IDEF1x se bazează pe modelul de entitate-relație și este destinat proiectării bazelor de date logice.
PAGINA 66
IDEF2 Modelarea prin simulare este un instrument de sprijinire a deciziilor care ajută la rezolvarea problemelor complexe din multe domenii de aplicație. Simularea permite construirea scenariilor „ce ar fi dacă” și analizarea posibilelor efecte ale acestora asupra unui sistem existent sau imaginar.
PAGINA 67
IDEF3 construiește modele ale proceselor întreprinderii și, prin urmare, este similar cu IDEF0, insa exista si o diferenta majora. IDEF3 conține două abordări de modelare: Descrierea fluxului de proces. Descrierea tranziției stării obiectului.
PAGINA 68
IDEF4 Metoda de proiectare orientată pe obiecte IDEF4 a fost concepută pentru a ajuta la aplicarea corectă a tehnologiei orientate pe obiecte. IDEF4 conține elemente tipice, de ex. submodele de clase și metode, diagrame de moștenire, diagrame de protocol, diagrame client, diagrame de instanțiere etc.
PAGINA 69
IDEF5 IDEF5 este o metodă de inginerie software pentru a dezvolta și menține ontologii de domeniu utilizabile și precise. IDEF5 oferă o metodă de a crea, modifica și menține ontologii, prin intermediul a două limbaje principale: limbajul schematic (grafic) și limbajul de elaborare (textual).
PAGINA 70
IDEF6 … IDEF14  Ceilalți membri ai familiei IDEF se ocupă cu o gamă largă de modelare de business și software.
PAGINA 71
IDEF0 (A-0) Diagramele IDEF0 pot fi descompuse în diagrame de nivel inferior („copil”). Ierarhia este menținută printr-un sistem de numerotare care organizează diagramele părinte și copil Se începe cu diagrama de Nivel 0 și apoi se va detalia în continuare până când se obține un grad suficient de granularitate.
PAGINA 72
IDEF0 (A-1) Următorul nivel în jos din diagrama A-0 este diagrama A0, care oferă un grad mai mare de granularitate a procesului. Principalele procese de afaceri sunt identificate aici, împreună cu ICOM - urile lor (Intrare (stânga), Ieșiri (dreapta), Controale (sus) și Mecanisme (jos))
PAGINA 73
IDEF0 (A-2) Pornind de la diagrama A0, orice funcție (caseta de pe diagramă) poate fi selectată pentru detalii suplimentare. Procesul #4 (Procure/Produce/Livrare) a fost ales pentru că promite a fi cel mai dinamic și mai interesant.
PAGINA 74
Comparatie IDEF0 nu reprezintă condițiile necesare pentru a intra sau a ieși dintr’un proces. De aceea, IDEF0 este cel mai bine utilizat în combinație cu alte metode IDEF (de exemplu IDEF3). IDEF1 nu poate fi utilizat direct în faza de implementare. Totuși, poate fi extrem de util în modelarea informațiilor din cadrul afacerii, fără constrângeri de implementare. IDEF1x este un instrument bun pentru baza de proiectare a bazei de date, dar nu urmează regulile unui design grafic bun - simbolurile sale nu se mapează în mod corespunzator la conceptele pe care ar trebui să le modeleze. IDEF3 este o metodă de captare a descrierilor și este concepută pentru a tolera descrierile parțiale și inconsecvente. Foarte des, aceste inconsecvențe devin rădăcina problemelor unei organizații și ar trebui abordate în mod corespunzător în reprezentarea IDEF3 și nu neglijate
PAGINA 75
IDEF vs. UML IDEF0 poate găsi un echivalent în diagramele de activitate UML folosind extensiile de afaceri specializate pentru modelarea proceselor. IDEF1 și IDEF1x sunt similare cu diagramele de clase și obiecte UML care exprimă aspectul static (arhitectural) al unui sistem. IDEF2 poate fi echivalent - într-o măsură - cu diagramele de colaborare, diagramele de activitate și stare în limbajul UML. Diagrama de descriere a procesului IDEF 3 este similară cu diagrama de activitate UML, în timp ce diagrama de tranziție a stării obiectului este similară cu diagramele de stare. IDEF3 este, de asemenea, similar cu diagrama de caz de utilizare privind conceptul de scenariu. IDEF4 este orientat în mod special către dezvoltarea de software și, ca atare, are asemănări cu diagramele de clasă, obiect, activitate și stare din UML. IDEF 5 poate fi comparat doar cu meta-meta-modelul (și poate cu nivelul meta-modelului) în UML, unde este definită ontologia limbajului.








